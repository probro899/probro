{"ast":null,"code":"var _arguments = arguments;\nimport shocketCommon from '@probro/common/proSocket-common';\n\nvar slicedToArray = function slicedToArray(arr, i) {\n  console.log('slicedToArray called', arr, i);\n  return arr;\n};\n\nvar noop = function noop() {};\n\nvar connect = function connect(url, store) {\n  var Socket = WebSocket;\n  var newtwork = null;\n  var parser = shocketCommon.createParser();\n  var serial = 0;\n  var scopeSerial = 0;\n  var rpcs = {};\n  var scopeCalls = {};\n  var scopeManifests = {};\n  var listeners = {};\n  var pending = [];\n\n  var fire = function fire(event, data) {\n    var eventListeners = listeners[event];\n\n    if (eventListeners) {\n      // Call the listeners with client as `this` instance\n      // eslint-disable-next-line no-use-before-define\n      eventListeners.forEach(function (element) {\n        return element.call(client, data);\n      });\n    }\n  };\n\n  var deferSend = function deferSend(pkt) {\n    pending.push(pkt);\n    return function () {\n      var idx = pending.indexOf(pkt);\n\n      if (idx >= 0) {\n        pending.splice(idx, 1);\n      }\n    };\n  };\n\n  var connection = function connection(remoteUrl) {\n    if (remoteUrl === null) {\n      return null;\n    }\n\n    var sock = new Socket(remoteUrl);\n\n    sock.onopen = function () {\n      // Execute all the pending calls\n      pending.forEach(function (p) {\n        return sock.send(p);\n      }); // empty pending pkt\n\n      pending.length = 0;\n      fire('connect');\n    }; // Listening all the incomming message\n\n\n    sock.onmessage = function (e) {\n      parser.parse(e.data);\n    }; // to do on socket closed\n\n\n    sock.onclose = function () {\n      // Clear all pending as they will be rejected from below\n      pending.length = 0; // Reject all rpcs and scopes with termination error\n\n      var rejections = Object.values(rpcs).concat(Object.values(scopeCalls));\n      rpcs = {};\n      scopeCalls = {};\n      rejections.forEach(function (ref) {\n        var ref2 = slicedToArray(ref, 2);\n        var reject = ref2[1];\n        reject(new Error('Connection terminated'));\n      }); // Clear all the scope manifests\n\n      scopeManifests = {};\n      fire('disconnect');\n    };\n\n    sock.onerror = function (e) {\n      var rejections = Object.values(rpcs).concat(Object.values(scopeCalls));\n      rpcs = {};\n      scopeCalls = {}; // Clear all pending tasks as they will be rejected from below\n\n      pending.length = 0; // Reject all rpcs and scopes with error\n\n      rejections.forEach(function (res) {\n        var ref = slicedToArray(res, 2);\n        var reject = ref[1];\n        reject(e.message);\n      }); // Fire the error event on client\n\n      fire('error', e.message);\n    };\n\n    return sock;\n  }; // assign onEvent of socket to this fire func\n\n\n  parser.onEvent = fire; // Handle action dispatch by server\n\n  parser.onAction = function (action) {\n    store.dispatch(action);\n  }; // Handle Remote procedure call response\n\n\n  parser.onRpcResponse = function (tracker, success, result) {\n    var rpcTracker = slicedToArray(rpcs[tracker], 2);\n    var resolve = rpcTracker[0];\n    var reject = rpcTracker[1];\n    delete rpcs[tracker];\n\n    if (success) {\n      resolve(result);\n    } else {\n      reject(result);\n    }\n  }; // Handle scope response\n\n\n  parser.onScopeResponse = function (tracker, success, result) {\n    var scopeCallTracker = slicedToArray(scopeCalls[tracker], 4);\n    var resolve = scopeCallTracker[0];\n    var reject = scopeCallTracker[1];\n    var scopeId = scopeCallTracker[2];\n    var manifest = scopeCallTracker[3];\n    delete scopeCalls[tracker];\n\n    if (!success) {\n      reject(result);\n    } else {\n      var apis = result || manifest.api;\n      var scopedApi = apis.reduce(function (res, api) {\n        res[api] = function () {\n          var argLenth = _arguments.length;\n          var args = Array(argLenth);\n\n          for (var key = 0; key < argLenth; key += 1) {\n            args[key] = _arguments[key];\n          }\n\n          return client.rpc.apply(client, [scopeId, api].concat(args));\n        };\n\n        return res;\n      }, {}); // Store the scond api for easy retrieval later\n\n      scopeManifests[scopeId] = scopedApi;\n      resolve(scopedApi);\n    }\n  }; // Initialize with a connection attemp\n\n\n  var socket = connection(url);\n  var client = {\n    // check socket is connected or not\n    isConnected: function isConnected() {\n      return socket && socket.readyState === Socket.OPEN;\n    },\n    // reconnect the socket if connect failer\n    reconnect: function reconnect() {\n      var remoteUrl = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : null; // Cannnot connect without a remote url\n\n      if (remoteUrl === null && socket === null) {\n        return false;\n      } // Use the given url or a last successfully connected url\n\n\n      var finalUrl = remoteUrl || socket.url; // Only perform a reconnect if the socket is not connected or the url has changed\n\n      if (socket === null || socket.url !== finalUrl || socket.readyState !== Socket.OPEN) {\n        // Make sure to clearnUp the previous socket\n        if (socket !== null) {\n          socket.close();\n        } // Perform a new connection\n\n\n        socket = connection(finalUrl); // The reconnection has been attempted\n\n        return true;\n      } // No reattempt needed\n\n\n      return false;\n    },\n    // close socket function\n    close: function close() {\n      socket.close();\n      socket = null;\n    },\n    on: function on(event, listener) {\n      // Keep track of event listeners\n      var eventListeners = listeners[event];\n\n      if (!eventListeners) {\n        listeners[event] = [listener];\n      } else {\n        eventListeners.push(listener);\n      }\n\n      return function () {\n        listeners[event] = listeners[event].filter(function (l) {\n          return l === listener;\n        });\n      };\n    },\n    call: function call(scope, api) {\n      var argLenth = _arguments.length;\n      var args = Array(argLenth > 2 ? argLenth - 2 : 0);\n\n      for (var key = 2; key < argLenth; key += 1) {\n        args[key - 2] = _arguments[key];\n      } // making packet to send\n\n\n      var pkt = shocketCommon.PKT_CALL(scope, api, args); // check socket is connected or not if not then store the packet for latter send\n\n      if (!client.isConnected()) {\n        return deferSend(pkt);\n      } // Send the request, its not an rpc so need to keep track\n\n\n      socket.send(pkt);\n      return noop;\n    },\n    rpc: function rpc(scope, api) {\n      var argLenth = _arguments.length;\n      var args = Array(argLenth > 2 ? argLenth - 2 : 0);\n\n      for (var key = 2; key < argLenth; key += 1) {\n        args[key - 2] = _arguments[key];\n      }\n\n      return new Promise(function (resolve, reject) {\n        serial += 1;\n        rpcs[serial] = [resolve, reject];\n        var pkt = shocketCommon.PKT_RPC_REQUEST(serial, scope, api, args);\n\n        if (client.isConnected()) {\n          return deferSend(pkt);\n        }\n\n        socket.send(pkt);\n        return noop();\n      });\n    },\n    scope: function scope(name) {\n      var manifest = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : null;\n      return new Promise(function (resolve, reject) {\n        // If the scope has already been manifested return immediately\n        if (scopeManifests[name]) {\n          return resolve(scopeManifests[name]);\n        }\n\n        scopeSerial += 1;\n        scopeCalls[scopeSerial] = [resolve, reject, name, manifest];\n        var pkt = shocketCommon.PKT_SCOPE_REQUEST(scopeSerial, name, !manifest);\n\n        if (client.isConnected()) {\n          return deferSend(pkt);\n        }\n\n        socket.send(pkt);\n        return noop;\n      });\n    }\n  }; // Setup a network change listener to keep the connection alive\n\n  if (newtwork) {\n    newtwork.on('online', function () {\n      // Establish a connection as soon as we are online\n      if (socket !== null) {\n        client.reconnect();\n      }\n    });\n    newtwork.on('offline', function () {\n      // close the socket as soon as we go offline\n      if (socket !== null) {\n        socket.close();\n      }\n    });\n  }\n\n  return client;\n};\n\nexport default connect;","map":{"version":3,"sources":["/home/bhagya/workspace/reactjs/projects/probro/packages/web/src/socket/main/connect.js"],"names":["shocketCommon","slicedToArray","arr","i","console","log","noop","connect","url","store","Socket","WebSocket","newtwork","parser","createParser","serial","scopeSerial","rpcs","scopeCalls","scopeManifests","listeners","pending","fire","event","data","eventListeners","forEach","element","call","client","deferSend","pkt","push","idx","indexOf","splice","connection","remoteUrl","sock","onopen","p","send","length","onmessage","e","parse","onclose","rejections","Object","values","concat","ref","ref2","reject","Error","onerror","res","message","onEvent","onAction","action","dispatch","onRpcResponse","tracker","success","result","rpcTracker","resolve","onScopeResponse","scopeCallTracker","scopeId","manifest","apis","api","scopedApi","reduce","argLenth","arguments","args","Array","key","rpc","apply","socket","isConnected","readyState","OPEN","reconnect","undefined","finalUrl","close","on","listener","filter","l","scope","PKT_CALL","Promise","PKT_RPC_REQUEST","name","PKT_SCOPE_REQUEST"],"mappings":"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","sourcesContent":["import shocketCommon from '@probro/common/proSocket-common';\n\nconst slicedToArray = (arr, i) => {\n  console.log('slicedToArray called', arr, i);\n  return arr;\n};\n\nconst noop = () => {};\n\nconst connect = (url, store) => {\n\n  const Socket = WebSocket;\n  const newtwork = null;\n\n  const parser = shocketCommon.createParser();\n\n  let serial = 0;\n  let scopeSerial = 0;\n  let rpcs = {};\n  let scopeCalls = {};\n  let scopeManifests = {};\n  const listeners = {};\n  const pending = [];\n\n  const fire = (event, data) => {\n    const eventListeners = listeners[event];\n    if (eventListeners) {\n      // Call the listeners with client as `this` instance\n      // eslint-disable-next-line no-use-before-define\n      eventListeners.forEach((element) => {\n        return element.call(client, data);\n      });\n    }\n  };\n\n  const deferSend = (pkt) => {\n    pending.push(pkt);\n    return () => {\n      let idx = pending.indexOf(pkt);\n      if (idx >= 0) {\n        pending.splice(idx, 1);\n      }\n    };\n  };\n\n  const connection = (remoteUrl) => {\n    if (remoteUrl === null) {\n      return null;\n    }\n\n    const sock = new Socket(remoteUrl);\n    sock.onopen = () => {\n      // Execute all the pending calls\n      pending.forEach((p) => {\n        return sock.send(p);\n      });\n\n      // empty pending pkt\n      pending.length = 0;\n      fire('connect');\n    };\n\n    // Listening all the incomming message\n    sock.onmessage = (e) => {\n      parser.parse(e.data);\n    };\n\n    // to do on socket closed\n\n    sock.onclose = () => {\n      // Clear all pending as they will be rejected from below\n      pending.length = 0;\n\n      // Reject all rpcs and scopes with termination error\n      const rejections = Object.values(rpcs).concat(Object.values(scopeCalls));\n      rpcs = {};\n      scopeCalls = {};\n      rejections.forEach((ref) => {\n        const ref2 = slicedToArray(ref, 2);\n        const reject = ref2[1];\n        reject(new Error('Connection terminated'));\n      });\n\n      // Clear all the scope manifests\n      scopeManifests = {};\n      fire('disconnect');\n    };\n\n    sock.onerror = (e) => {\n      const rejections = Object.values(rpcs).concat(Object.values(scopeCalls));\n      rpcs = {};\n      scopeCalls = {};\n\n      // Clear all pending tasks as they will be rejected from below\n      pending.length = 0;\n\n      // Reject all rpcs and scopes with error\n      rejections.forEach((res) => {\n        const ref = slicedToArray(res, 2);\n        const reject = ref[1];\n        reject(e.message);\n      });\n\n      // Fire the error event on client\n      fire('error', e.message);\n    };\n\n    return sock;\n  };\n\n  // assign onEvent of socket to this fire func\n  parser.onEvent = fire;\n\n  // Handle action dispatch by server\n  parser.onAction = (action) => {\n    store.dispatch(action);\n  };\n\n  // Handle Remote procedure call response\n  parser.onRpcResponse = (tracker, success, result) => {\n    const rpcTracker = slicedToArray(rpcs[tracker], 2);\n    const resolve = rpcTracker[0];\n    const reject = rpcTracker[1];\n    delete rpcs[tracker];\n\n    if (success) {\n      resolve(result);\n    } else {\n      reject(result);\n    }\n  };\n\n  // Handle scope response\n  parser.onScopeResponse = (tracker, success, result) => {\n    const scopeCallTracker = slicedToArray(scopeCalls[tracker], 4);\n    const resolve = scopeCallTracker[0];\n    const reject = scopeCallTracker[1];\n    const scopeId = scopeCallTracker[2];\n    const manifest = scopeCallTracker[3];\n\n    delete scopeCalls[tracker];\n    if (!success) {\n      reject(result);\n    } else {\n      const apis = result || manifest.api;\n\n      const scopedApi = apis.reduce((res, api) => {\n\n        res[api] = () => {\n          const argLenth = arguments.length;\n          const args = Array(argLenth);\n          for (let key = 0; key < argLenth; key += 1) {\n            args[key] = arguments[key];\n          }\n          return client.rpc.apply(client, [scopeId, api, ...args]);\n        };\n        return res;\n      }, {});\n\n      // Store the scond api for easy retrieval later\n      scopeManifests[scopeId] = scopedApi;\n      resolve(scopedApi);\n    }\n  };\n\n  // Initialize with a connection attemp\n  let socket = connection(url);\n\n  let client = {\n    // check socket is connected or not\n    isConnected: () => {\n      return socket && socket.readyState === Socket.OPEN;\n    },\n\n    // reconnect the socket if connect failer\n    reconnect: () => {\n      let remoteUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      // Cannnot connect without a remote url\n      if (remoteUrl === null && socket === null) {\n        return false;\n      }\n\n      // Use the given url or a last successfully connected url\n      let finalUrl = remoteUrl || socket.url;\n\n      // Only perform a reconnect if the socket is not connected or the url has changed\n\n      if (socket === null || socket.url !== finalUrl || socket.readyState !== Socket.OPEN) {\n        // Make sure to clearnUp the previous socket\n\n        if (socket !== null) {\n          socket.close();\n        }\n\n        // Perform a new connection\n        socket = connection(finalUrl);\n        // The reconnection has been attempted\n        return true;\n      }\n\n      // No reattempt needed\n\n      return false;\n    },\n    // close socket function\n    close: () => {\n      socket.close();\n      socket = null;\n    },\n\n    on: (event, listener) => {\n      // Keep track of event listeners\n      const eventListeners = listeners[event];\n\n      if (!eventListeners) {\n        listeners[event] = [listener];\n      } else {\n        eventListeners.push(listener);\n      }\n\n      return () => {\n        listeners[event] = listeners[event].filter(l => l === listener);\n      };\n    },\n\n    call: (scope, api) => {\n      const argLenth = arguments.length;\n      const args = Array(argLenth > 2 ? argLenth - 2 : 0);\n      for (let key = 2; key < argLenth; key += 1) {\n        args[key - 2] = arguments[key];\n      }\n\n      // making packet to send\n      const pkt = shocketCommon.PKT_CALL(scope, api, args);\n      // check socket is connected or not if not then store the packet for latter send\n      if (!client.isConnected()) {\n        return deferSend(pkt);\n      }\n      // Send the request, its not an rpc so need to keep track\n      socket.send(pkt);\n      return noop;\n    },\n\n    rpc: (scope, api) => {\n      const argLenth = arguments.length;\n      const args = Array(argLenth > 2 ? argLenth - 2 : 0);\n      for (let key = 2; key < argLenth; key += 1) {\n        args[key - 2] = arguments[key];\n      }\n\n      return new Promise((resolve, reject) => {\n        serial += 1;\n        rpcs[serial] = [resolve, reject];\n\n        const pkt = shocketCommon.PKT_RPC_REQUEST(serial, scope, api, args);\n\n        if (client.isConnected()) {\n          return deferSend(pkt);\n        }\n        socket.send(pkt);\n        return noop();\n      });\n    },\n\n    scope: (name) => {\n      const manifest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      return new Promise((resolve, reject) => {\n        // If the scope has already been manifested return immediately\n\n        if (scopeManifests[name]) {\n          return resolve(scopeManifests[name]);\n        }\n\n        scopeSerial += 1;\n        scopeCalls[scopeSerial] = [resolve, reject, name, manifest];\n\n        const pkt = shocketCommon.PKT_SCOPE_REQUEST(scopeSerial, name, !manifest);\n\n        if (client.isConnected()) {\n          return deferSend(pkt);\n        }\n\n        socket.send(pkt);\n        return noop;\n      });\n    }\n  };\n\n  // Setup a network change listener to keep the connection alive\n\n  if (newtwork) {\n    newtwork.on('online', () => {\n      // Establish a connection as soon as we are online\n\n      if (socket !== null) {\n        client.reconnect();\n      }\n    });\n\n    newtwork.on('offline', () => {\n      // close the socket as soon as we go offline\n\n      if (socket !== null) {\n        socket.close();\n      }\n    });\n  }\n\n  return client;\n};\n\nexport default connect;\n"]},"metadata":{},"sourceType":"module"}