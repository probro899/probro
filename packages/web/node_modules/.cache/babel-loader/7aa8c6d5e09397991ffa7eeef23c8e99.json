{"ast":null,"code":"import { createParser, PKT_CALL, PKT_RPC_REQUEST, PKT_SCOPE_REQUEST } from '@probro/common/proSocket-common';\n\nvar slicedToArray = function slicedToArray(arr, i) {\n  // console.log('slicedToArray called', arr, i);\n  return arr;\n};\n\nvar noop = function noop() {};\n\nvar connect = function connect(url, store) {\n  // console.log('connect socket is called', url, store);\n  var Socket = WebSocket;\n  var newtwork = null;\n  var parser = createParser();\n  var serial = 0;\n  var scopeSerial = 0;\n  var rpcs = {};\n  var scopeCalls = {};\n  var scopeManifests = {};\n  var listeners = {};\n  var pending = [];\n\n  var fire = function fire(event, data) {\n    var eventListeners = listeners[event];\n\n    if (eventListeners) {\n      // Call the listeners with client as `this` instance\n      // eslint-disable-next-line no-use-before-define\n      eventListeners.forEach(function (element) {\n        return element.call(client, data);\n      });\n    }\n  };\n\n  var deferSend = function deferSend(pkt) {\n    pending.push(pkt);\n    return function () {\n      var idx = pending.indexOf(pkt);\n\n      if (idx >= 0) {\n        pending.splice(idx, 1);\n      }\n    };\n  };\n\n  var connection = function connection(remoteUrl) {\n    if (remoteUrl === null) {\n      return null;\n    }\n\n    var sock = new Socket(remoteUrl);\n\n    sock.onopen = function () {\n      // Execute all the pending calls\n      pending.forEach(function (p) {\n        return sock.send(p);\n      }); // empty pending pkt\n\n      pending.length = 0;\n      fire('connect');\n    }; // Listening all the incomming message\n\n\n    sock.onmessage = function (e) {\n      console.log('data in socket from sever', e.data);\n      parser.parse(e.data);\n    }; // to do on socket closed\n\n\n    sock.onclose = function () {\n      // Clear all pending as they will be rejected from below\n      pending.length = 0; // Reject all rpcs and scopes with termination error\n\n      var rejections = Object.values(rpcs).concat(Object.values(scopeCalls));\n      rpcs = {};\n      scopeCalls = {};\n      rejections.forEach(function (ref) {\n        var ref2 = slicedToArray(ref, 2);\n        var reject = ref2[1];\n        reject(new Error('Connection terminated'));\n      }); // Clear all the scope manifests\n\n      scopeManifests = {};\n      fire('disconnect');\n    };\n\n    sock.onerror = function (e) {\n      var rejections = Object.values(rpcs).concat(Object.values(scopeCalls));\n      rpcs = {};\n      scopeCalls = {}; // Clear all pending tasks as they will be rejected from below\n\n      pending.length = 0; // Reject all rpcs and scopes with error\n\n      rejections.forEach(function (res) {\n        var ref = slicedToArray(res, 2);\n        var reject = ref[1];\n        reject(e.message);\n      }); // Fire the error event on client\n\n      fire('error', e.message);\n    };\n\n    return sock;\n  }; // assign onEvent of socket to this fire func\n\n\n  parser.onEvent = fire; // Handle action dispatch by server\n\n  parser.onAction = function (action) {\n    console.log('action called', action);\n    store.dispatch(action);\n  }; // Handle Remote procedure call response\n\n\n  parser.onRpcResponse = function (tracker, success, result) {\n    var rpcTracker = slicedToArray(rpcs[tracker], 2);\n    var resolve = rpcTracker[0];\n    var reject = rpcTracker[1];\n    delete rpcs[tracker];\n\n    if (success) {\n      resolve(result);\n    } else {\n      reject(result);\n    }\n  }; // Handle scope response\n\n\n  parser.onScopeResponse = function (tracker, success, result) {\n    console.log('scope response called', tracker, success, result);\n    var scopeCallTracker = slicedToArray(scopeCalls[tracker], 4);\n    var resolve = scopeCallTracker[0];\n    var reject = scopeCallTracker[1];\n    var scopeId = scopeCallTracker[2];\n    var manifest = scopeCallTracker[3];\n    delete scopeCalls[tracker];\n\n    if (!success) {\n      reject(result);\n    } else {\n      var apis = result || manifest.api;\n      var scopedApi = apis.reduce(function (res, api) {\n        res[api] = function () {\n          for (var _len = arguments.length, Arguments = new Array(_len), _key = 0; _key < _len; _key++) {\n            Arguments[_key] = arguments[_key];\n          }\n\n          var argLenth = [Arguments].length;\n          var args = Array(argLenth);\n\n          for (var key = 0; key < argLenth; key += 1) {\n            args[key] = Arguments[key];\n          }\n\n          return client.rpc.apply(client, [scopeId, api].concat(args));\n        };\n\n        return res;\n      }, {}); // Store the scond api for easy retrieval later\n\n      scopeManifests[scopeId] = scopedApi;\n      resolve(scopedApi);\n    }\n  }; // Initialize with a connection attemp\n\n\n  var socket = connection(url);\n  var client = {\n    // check socket is connected or not\n    isConnected: function isConnected() {\n      return socket && socket.readyState === Socket.OPEN;\n    },\n    // reconnect the socket if connect failer\n    reconnect: function reconnect() {\n      for (var _len2 = arguments.length, Arguments = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        Arguments[_key2] = arguments[_key2];\n      }\n\n      console.log('reconnect', Arguments);\n      var remoteUrl = Arguments.length > 0 && Arguments[0] !== undefined ? Arguments[0] : null; // Cannnot connect without a remote url\n\n      if (remoteUrl === null && socket === null) {\n        return false;\n      } // Use the given url or a last successfully connected url\n\n\n      var finalUrl = remoteUrl || socket.url; // Only perform a reconnect if the socket is not connected or the url has changed\n\n      if (socket === null || socket.url !== finalUrl || socket.readyState !== Socket.OPEN) {\n        // Make sure to clearnUp the previous socket\n        if (socket !== null) {\n          socket.close();\n        } // Perform a new connection\n\n\n        socket = connection(finalUrl); // The reconnection has been attempted\n\n        return true;\n      } // No reattempt needed\n\n\n      return false;\n    },\n    // close socket function\n    close: function close() {\n      socket.close();\n      socket = null;\n    },\n    on: function on(event, listener) {\n      // Keep track of event listeners\n      var eventListeners = listeners[event];\n\n      if (!eventListeners) {\n        listeners[event] = [listener];\n      } else {\n        eventListeners.push(listener);\n      }\n\n      return function () {\n        listeners[event] = listeners[event].filter(function (l) {\n          return l === listener;\n        });\n      };\n    },\n    call: function call(scope, api) {\n      var argLenth = arguments.length <= 2 ? 0 : arguments.length - 2;\n      var args = Array(argLenth > 2 ? argLenth - 2 : 0);\n\n      for (var key = 2; key < argLenth; key += 1) {\n        args[key - 2] = key + 2 < 2 || arguments.length <= key + 2 ? undefined : arguments[key + 2];\n      } // making packet to send\n\n\n      var pkt = PKT_CALL(scope, api, args); // check socket is connected or not if not then store the packet for latter send\n\n      if (!client.isConnected()) {\n        return deferSend(pkt);\n      } // Send the request, its not an rpc so need to keep track\n\n\n      socket.send(pkt);\n      return noop;\n    },\n    rpc: function rpc(scope, api) {\n      for (var _len3 = arguments.length, Arguments = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        Arguments[_key3 - 2] = arguments[_key3];\n      }\n\n      console.log('rpc called', scope, api, Arguments);\n      var argLenth = Arguments.length;\n      var args = Array(argLenth > 2 ? argLenth - 2 : 0);\n\n      for (var key = 2; key < argLenth; key += 1) {\n        args[key - 2] = Arguments[key];\n      }\n\n      return new Promise(function (resolve, reject) {\n        serial += 1;\n        rpcs[serial] = [resolve, reject];\n        var pkt = PKT_RPC_REQUEST(serial, scope, api, args);\n\n        if (client.isConnected()) {\n          return deferSend(pkt);\n        }\n\n        socket.send(pkt);\n        return noop();\n      });\n    },\n    scope: function scope(name) {\n      for (var _len4 = arguments.length, Arguments = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        Arguments[_key4 - 1] = arguments[_key4];\n      }\n\n      console.log('scope', name, Arguments);\n      var manifest = Arguments.length > 1 && Arguments[1] !== undefined ? Arguments[1] : null;\n      return new Promise(function (resolve, reject) {\n        // If the scope has already been manifested return immediately\n        if (scopeManifests[name]) {\n          return resolve(scopeManifests[name]);\n        }\n\n        scopeSerial += 1;\n        scopeCalls[scopeSerial] = [resolve, reject, name, manifest];\n        var pkt = PKT_SCOPE_REQUEST(scopeSerial, name, !manifest);\n\n        if (!client.isConnected()) {\n          return deferSend(pkt);\n        }\n\n        socket.send(pkt);\n        return noop;\n      });\n    }\n  }; // Setup a network change listener to keep the connection alive\n\n  if (newtwork) {\n    newtwork.on('online', function () {\n      // Establish a connection as soon as we are online\n      if (socket !== null) {\n        client.reconnect();\n      }\n    });\n    newtwork.on('offline', function () {\n      // close the socket as soon as we go offline\n      if (socket !== null) {\n        socket.close();\n      }\n    });\n  }\n\n  return client;\n};\n\nexport default connect;","map":{"version":3,"sources":["/home/bhagya/workspace/reactjs/projects/probro/packages/web/src/socket/main/connect.js"],"names":["createParser","PKT_CALL","PKT_RPC_REQUEST","PKT_SCOPE_REQUEST","slicedToArray","arr","i","noop","connect","url","store","Socket","WebSocket","newtwork","parser","serial","scopeSerial","rpcs","scopeCalls","scopeManifests","listeners","pending","fire","event","data","eventListeners","forEach","element","call","client","deferSend","pkt","push","idx","indexOf","splice","connection","remoteUrl","sock","onopen","p","send","length","onmessage","e","console","log","parse","onclose","rejections","Object","values","concat","ref","ref2","reject","Error","onerror","res","message","onEvent","onAction","action","dispatch","onRpcResponse","tracker","success","result","rpcTracker","resolve","onScopeResponse","scopeCallTracker","scopeId","manifest","apis","api","scopedApi","reduce","Arguments","argLenth","args","Array","key","rpc","apply","socket","isConnected","readyState","OPEN","reconnect","undefined","finalUrl","close","on","listener","filter","l","scope","Promise","name"],"mappings":"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","sourcesContent":["import { createParser, PKT_CALL, PKT_RPC_REQUEST, PKT_SCOPE_REQUEST } from '@probro/common/proSocket-common';\n\nconst slicedToArray = (arr, i) => {\n  // console.log('slicedToArray called', arr, i);\n  return arr;\n};\n\nconst noop = () => {};\n\nconst connect = (url, store) => {\n  // console.log('connect socket is called', url, store);\n\n  const Socket = WebSocket;\n  const newtwork = null;\n\n  const parser = createParser();\n\n  let serial = 0;\n  let scopeSerial = 0;\n  let rpcs = {};\n  let scopeCalls = {};\n  let scopeManifests = {};\n  const listeners = {};\n  const pending = [];\n\n  const fire = (event, data) => {\n    const eventListeners = listeners[event];\n    if (eventListeners) {\n      // Call the listeners with client as `this` instance\n      // eslint-disable-next-line no-use-before-define\n      eventListeners.forEach((element) => {\n        return element.call(client, data);\n      });\n    }\n  };\n\n  const deferSend = (pkt) => {\n    pending.push(pkt);\n    return () => {\n      let idx = pending.indexOf(pkt);\n      if (idx >= 0) {\n        pending.splice(idx, 1);\n      }\n    };\n  };\n\n  const connection = (remoteUrl) => {\n    if (remoteUrl === null) {\n      return null;\n    }\n\n    const sock = new Socket(remoteUrl);\n    sock.onopen = () => {\n      // Execute all the pending calls\n      pending.forEach((p) => {\n        return sock.send(p);\n      });\n\n      // empty pending pkt\n      pending.length = 0;\n      fire('connect');\n    };\n\n    // Listening all the incomming message\n    sock.onmessage = (e) => {\n      console.log('data in socket from sever', e.data);\n      parser.parse(e.data);\n    };\n\n    // to do on socket closed\n\n    sock.onclose = () => {\n      // Clear all pending as they will be rejected from below\n      pending.length = 0;\n\n      // Reject all rpcs and scopes with termination error\n      const rejections = Object.values(rpcs).concat(Object.values(scopeCalls));\n      rpcs = {};\n      scopeCalls = {};\n      rejections.forEach((ref) => {\n        const ref2 = slicedToArray(ref, 2);\n        const reject = ref2[1];\n        reject(new Error('Connection terminated'));\n      });\n\n      // Clear all the scope manifests\n      scopeManifests = {};\n      fire('disconnect');\n    };\n\n    sock.onerror = (e) => {\n      const rejections = Object.values(rpcs).concat(Object.values(scopeCalls));\n      rpcs = {};\n      scopeCalls = {};\n\n      // Clear all pending tasks as they will be rejected from below\n      pending.length = 0;\n\n      // Reject all rpcs and scopes with error\n      rejections.forEach((res) => {\n        const ref = slicedToArray(res, 2);\n        const reject = ref[1];\n        reject(e.message);\n      });\n\n      // Fire the error event on client\n      fire('error', e.message);\n    };\n\n    return sock;\n  };\n\n  // assign onEvent of socket to this fire func\n  parser.onEvent = fire;\n\n  // Handle action dispatch by server\n  parser.onAction = (action) => {\n    console.log('action called', action);\n    store.dispatch(action);\n  };\n\n  // Handle Remote procedure call response\n  parser.onRpcResponse = (tracker, success, result) => {\n    const rpcTracker = slicedToArray(rpcs[tracker], 2);\n    const resolve = rpcTracker[0];\n    const reject = rpcTracker[1];\n    delete rpcs[tracker];\n\n    if (success) {\n      resolve(result);\n    } else {\n      reject(result);\n    }\n  };\n\n  // Handle scope response\n  parser.onScopeResponse = (tracker, success, result) => {\n    console.log('scope response called', tracker, success, result);\n    const scopeCallTracker = slicedToArray(scopeCalls[tracker], 4);\n    const resolve = scopeCallTracker[0];\n    const reject = scopeCallTracker[1];\n    const scopeId = scopeCallTracker[2];\n    const manifest = scopeCallTracker[3];\n\n    delete scopeCalls[tracker];\n    if (!success) {\n      reject(result);\n    } else {\n      const apis = result || manifest.api;\n\n      const scopedApi = apis.reduce((res, api) => {\n\n        res[api] = (...Arguments) => {\n          const argLenth = [Arguments].length;\n          const args = Array(argLenth);\n          for (let key = 0; key < argLenth; key += 1) {\n            args[key] = Arguments[key];\n          }\n          return client.rpc.apply(client, [scopeId, api, ...args]);\n        };\n        return res;\n      }, {});\n\n      // Store the scond api for easy retrieval later\n      scopeManifests[scopeId] = scopedApi;\n      resolve(scopedApi);\n    }\n  };\n\n  // Initialize with a connection attemp\n  let socket = connection(url);\n\n  let client = {\n    // check socket is connected or not\n    isConnected: () => {\n      return socket && socket.readyState === Socket.OPEN;\n    },\n\n    // reconnect the socket if connect failer\n    reconnect: (...Arguments) => {\n      console.log('reconnect', Arguments);\n      const remoteUrl = Arguments.length > 0 && Arguments[0] !== undefined ? Arguments[0] : null;\n\n      // Cannnot connect without a remote url\n      if (remoteUrl === null && socket === null) {\n        return false;\n      }\n\n      // Use the given url or a last successfully connected url\n      let finalUrl = remoteUrl || socket.url;\n\n      // Only perform a reconnect if the socket is not connected or the url has changed\n\n      if (socket === null || socket.url !== finalUrl || socket.readyState !== Socket.OPEN) {\n        // Make sure to clearnUp the previous socket\n\n        if (socket !== null) {\n          socket.close();\n        }\n\n        // Perform a new connection\n        socket = connection(finalUrl);\n        // The reconnection has been attempted\n        return true;\n      }\n\n      // No reattempt needed\n\n      return false;\n    },\n    // close socket function\n    close: () => {\n      socket.close();\n      socket = null;\n    },\n\n    on: (event, listener) => {\n      // Keep track of event listeners\n      const eventListeners = listeners[event];\n\n      if (!eventListeners) {\n        listeners[event] = [listener];\n      } else {\n        eventListeners.push(listener);\n      }\n\n      return () => {\n        listeners[event] = listeners[event].filter(l => l === listener);\n      };\n    },\n\n    call: (scope, api, ...Arguments) => {\n      const argLenth = Arguments.length;\n      const args = Array(argLenth > 2 ? argLenth - 2 : 0);\n      for (let key = 2; key < argLenth; key += 1) {\n        args[key - 2] = Arguments[key];\n      }\n\n      // making packet to send\n      const pkt = PKT_CALL(scope, api, args);\n      // check socket is connected or not if not then store the packet for latter send\n      if (!client.isConnected()) {\n        return deferSend(pkt);\n      }\n      // Send the request, its not an rpc so need to keep track\n      socket.send(pkt);\n      return noop;\n    },\n\n    rpc: (scope, api, ...Arguments) => {\n      console.log('rpc called', scope, api, Arguments);\n      const argLenth = Arguments.length;\n      const args = Array(argLenth > 2 ? argLenth - 2 : 0);\n      for (let key = 2; key < argLenth; key += 1) {\n        args[key - 2] = Arguments[key];\n      }\n\n      return new Promise((resolve, reject) => {\n        serial += 1;\n        rpcs[serial] = [resolve, reject];\n\n        const pkt = PKT_RPC_REQUEST(serial, scope, api, args);\n\n        if (client.isConnected()) {\n          return deferSend(pkt);\n        }\n        socket.send(pkt);\n        return noop();\n      });\n    },\n\n    scope: (name, ...Arguments) => {\n      console.log('scope', name, Arguments);\n      const manifest = Arguments.length > 1 && Arguments[1] !== undefined ? Arguments[1] : null;\n\n      return new Promise((resolve, reject) => {\n        // If the scope has already been manifested return immediately\n\n        if (scopeManifests[name]) {\n          return resolve(scopeManifests[name]);\n        }\n\n        scopeSerial += 1;\n        scopeCalls[scopeSerial] = [resolve, reject, name, manifest];\n\n        const pkt = PKT_SCOPE_REQUEST(scopeSerial, name, !manifest);\n\n        if (!client.isConnected()) {\n          return deferSend(pkt);\n        }\n\n        socket.send(pkt);\n        return noop;\n      });\n    },\n  };\n\n  // Setup a network change listener to keep the connection alive\n\n  if (newtwork) {\n    newtwork.on('online', () => {\n      // Establish a connection as soon as we are online\n\n      if (socket !== null) {\n        client.reconnect();\n      }\n    });\n\n    newtwork.on('offline', () => {\n      // close the socket as soon as we go offline\n\n      if (socket !== null) {\n        socket.close();\n      }\n    });\n  }\n\n  return client;\n};\n\nexport default connect;\n"]},"metadata":{},"sourceType":"module"}